13a14
> #include <conf.h>
23c24
< #include "mem.h"
---
> #include "u_mem.h"
31a33
> #include "bitmap.h"
133a136
> 
135a139,156
> //hack to allow color codes to be embedded in strings -MPM
> //note we subtract one from color, since 255 is "transparent" so it'll never be used, and 0 would otherwise end the string.
> //function must already have orig_color var set (or they could be passed as args...)
> //perhaps some sort of recursive orig_color type thing would be better, but that would be way too much trouble for little gain
> int gr_message_color_level=1;
> #define CHECK_EMBEDDED_COLORS() if ((*text_ptr >= 0x01) && (*text_ptr <= 0x03)) { \
> 		text_ptr++; \
> 		if (*text_ptr){ \
> 			if (gr_message_color_level >= *(text_ptr-1)) \
> 				FG_COLOR = *text_ptr - 1; \
> 			text_ptr++; \
> 		} \
> 	} \
> 	else if ((*text_ptr >= 0x04) && (*text_ptr <= 0x06)){ \
> 		if (gr_message_color_level >= *text_ptr - 3) \
> 			FG_COLOR=orig_color; \
> 		text_ptr++; \
> 	}
359c380
< 
---
> #ifdef __ENV_MSDOS__ 
749a771
> #endif
975a998
> #ifndef OGL
1049a1073,1336
> #else // OGL
> 
> #include "../main/inferno.h"
> #include "ogl_init.h"
> #include "args.h"
> //font handling routines for OpenGL - Added 9/25/99 Matthew Mueller - they are here instead of in arch/ogl because they use all these defines
> 
> int pow2ize(int x);//from ogl.c
> 
> int get_font_total_width(grs_font * font){
> 	if (font->ft_flags & FT_PROPORTIONAL){
> 		int i,w=0,c=font->ft_minchar;
> 		for (i=0;c<=font->ft_maxchar;i++,c++){
> 			if (font->ft_widths[i]<0)
> 				Error("heh?\n");
> 			w+=font->ft_widths[i];
> 		}
> 		return w;
> 	}else{
> 		return font->ft_w*(font->ft_maxchar-font->ft_minchar+1);
> 	}
> }
> void ogl_font_choose_size(grs_font * font,int gap,int *rw,int *rh){
> 	int	nchars = font->ft_maxchar-font->ft_minchar+1;
> 	int r,x,y,nc=0,smallest=999999,smallr=-1,tries;
> 	int smallprop=10000;
> 	int h,w;
> 	for (h=32;h<=256;h*=2){
> //		h=pow2ize(font->ft_h*rows+gap*(rows-1));
> 		if (font->ft_h>h)continue;
> 		r=(h/(font->ft_h+gap));
> 		w=pow2ize((get_font_total_width(font)+(nchars-r)*gap)/r);
> 		tries=0;
> 		do {
> 			if (tries)
> 				w=pow2ize(w+1);
> 			if(tries>3){
> 				mprintf((0,"failed to fit (%ix%i, %ic)\n",w,h,nc));
> 				break;
> 			}
> 			nc=0;
> 			y=0;
> 			while(y+font->ft_h<=h){
> 				x=0;
> 				while (x<w){
> 					if (nc==nchars)
> 						break;
> 					if (font->ft_flags & FT_PROPORTIONAL){
> 						if (x+font->ft_widths[nc]+gap>w)break;
> 						x+=font->ft_widths[nc++]+gap;
> 					}else{
> 						if (x+font->ft_w+gap>w)break;
> 						x+=font->ft_w+gap;
> 						nc++;
> 					}
> 				}
> 				if (nc==nchars)
> 					break;
> 				y+=font->ft_h+gap;
> 			}
> 			
> 			tries++;
> 		}while(nc!=nchars);
> 		if (nc!=nchars)
> 			continue;
> 		mprintf((0,"fit: %ix%i  %i tries\n",w,h,tries));
> 
> 		if (w*h==smallest){//this gives squarer sizes priority (ie, 128x128 would be better than 512*32)
> 			if (w>=h){
> 				if (w/h<smallprop){
> 					smallprop=w/h;
> 					smallest++;//hack
> 				}
> 			}else{
> 				if (h/w<smallprop){
> 					smallprop=h/w;
> 					smallest++;//hack
> 				}
> 			}
> 		}
> 		if (w*h<smallest){
> 			smallr=1;
> 			smallest=w*h;
> 			*rw=w;
> 			*rh=h;
> 		}
> 	}
> 	if (smallr<=0)
> 		Error("couldn't fit font?\n");
> 	mprintf((0,"using %ix%i\n",*rw,*rh));
> 	printf("using %ix%i\n",*rw,*rh);
> 	
> }
> 
> void ogl_init_font(grs_font * font){
> 	int	nchars = font->ft_maxchar-font->ft_minchar+1;
> 	int i,w,h,tw,th,x,y,curx=0,cury=0;
> 	char *fp;
> 	//	char data[32*32*4];
> 	char *data;
> 	int gap=0;//having a gap just wastes ram, since we don't filter text textures at all.
> 	//	char s[2];
> 	ogl_font_choose_size(font,gap,&tw,&th);
> 	data=malloc(tw*th);
> 	gr_init_bitmap(&font->ft_parent_bitmap,BM_LINEAR,0,0,tw,th,tw,data);
> 
> 	font->ft_parent_bitmap.gltexture=ogl_get_free_texture();
> 
> 	font->ft_bitmaps=(grs_bitmap*)malloc( nchars * sizeof(grs_bitmap));
> 	mprintf((0,"ogl_init_font %s, %s, nchars=%i, (%ix%i tex)\n",(font->ft_flags & FT_PROPORTIONAL)?"proportional":"fixedwidth",(font->ft_flags & FT_COLOR)?"color":"mono",nchars,tw,th));
> 	//	s[1]=0;
> 	h=font->ft_h;
> 	//	sleep(5);
> 
> 	for(i=0;i<nchars;i++){
> 		//		s[0]=font->ft_minchar+i;
> 		//		gr_get_string_size(s,&w,&h,&aw);
> 		if (font->ft_flags & FT_PROPORTIONAL)
> 			w=font->ft_widths[i];
> 		else
> 			w=font->ft_w;
> //		mprintf((0,"char %i(%ix%i): ",i,w,h));
> 		if (w<1 || w>256){
> 			mprintf((0,"grr\n"));continue;
> 		}
> 		if (curx+w+gap>tw){
> 			cury+=h+gap;
> 			curx=0;
> 		}
> 		if (cury+h>th)
> 			Error("font doesn't really fit (%i/%i)?\n",i,nchars);
> 		if (font->ft_flags & FT_COLOR) {
> 			if (font->ft_flags & FT_PROPORTIONAL)
> 				fp = font->ft_chars[i];
> 			else
> 				fp = font->ft_data + i * w*h;
> 			for (y=0;y<h;y++)
> 				for (x=0;x<w;x++){
> 					font->ft_parent_bitmap.bm_data[curx+x+(cury+y)*tw]=fp[x+y*w];
> 				}
> 
> 			//			gr_init_bitmap(&font->ft_bitmaps[i],BM_LINEAR,0,0,w,h,w,font->);
> 		}else{
> 			int BitMask,bits=0,white=gr_find_closest_color(63,63,63);
> 			//			if (w*h>sizeof(data))
> 			//				Error("ogl_init_font: toobig\n");
> 			if (font->ft_flags & FT_PROPORTIONAL)
> 				fp = font->ft_chars[i];
> 			else
> 				fp = font->ft_data + i * BITS_TO_BYTES(w)*h;
> 			for (y=0;y<h;y++){
> 				BitMask=0;
> 				for (x=0; x< w; x++ )
> 				{
> 					if (BitMask==0) {
> 						bits = *fp++;
> 						BitMask = 0x80;
> 					}
> 
> 					if (bits & BitMask)
> 						font->ft_parent_bitmap.bm_data[curx+x+(cury+y)*tw]=white;
> 					else
> 						font->ft_parent_bitmap.bm_data[curx+x+(cury+y)*tw]=255;
> 					BitMask >>= 1;
> 				}
> 			}
> 		}
> 		gr_init_sub_bitmap(&font->ft_bitmaps[i],&font->ft_parent_bitmap,curx,cury,w,h);
> 
> 		curx+=w+gap;
> 	}
> 	if (!(font->ft_flags & FT_COLOR)) {
> 		//use GL_INTENSITY instead of GL_RGB
> 		if (ogl_intensity4_ok){
> 			font->ft_parent_bitmap.gltexture->internalformat=GL_INTENSITY4;
> 			font->ft_parent_bitmap.gltexture->format=GL_LUMINANCE;
> 		}else if (ogl_luminance4_alpha4_ok){
> 			font->ft_parent_bitmap.gltexture->internalformat=GL_LUMINANCE4_ALPHA4;
> 			font->ft_parent_bitmap.gltexture->format=GL_LUMINANCE_ALPHA;
> 		}else if (ogl_rgba2_ok){
> 			font->ft_parent_bitmap.gltexture->internalformat=GL_RGBA2;
> 			font->ft_parent_bitmap.gltexture->format=GL_RGBA;
> 		}else{
> 			font->ft_parent_bitmap.gltexture->internalformat=ogl_rgba_format;
> 			font->ft_parent_bitmap.gltexture->format=GL_RGBA;
> 		}
> 	}
> 	ogl_loadbmtexture_m(&font->ft_parent_bitmap,0);
> }
> 
> int ogl_internal_string(int x, int y, char *s )
> {
> 	ubyte * text_ptr, * next_row, * text_ptr1;
> 	int width, spacing,letter;
> 	int xx,yy;
> 	int orig_color=FG_COLOR;//to allow easy reseting to default string color with colored strings -MPM
> 
> 	next_row = s;
> 
> 	yy = y;
> 
> 	if (grd_curscreen->sc_canvas.cv_bitmap.bm_type != BM_OGL)
> 		Error("carp.\n");
> 	while (next_row != NULL)
> 	{
> 		text_ptr1 = next_row;
> 		next_row = NULL;
> 
> 		text_ptr = text_ptr1;
> 
> 		xx = x;
> 
> 		if (xx==0x8000)			//centered
> 			xx = get_centered_x(text_ptr);
> 
> 		while (*text_ptr)
> 		{
> 			if (*text_ptr == '\n' )
> 			{
> 				next_row = &text_ptr[1];
> 				yy += FHEIGHT;
> 				break;
> 			}
> 
> 			letter = *text_ptr-FMINCHAR;
> 
> 			get_char_width(text_ptr[0],text_ptr[1],&width,&spacing);
> 
> 			if (!INFONT(letter) || *text_ptr<=0x06) {	//not in font, draw as space
> 				CHECK_EMBEDDED_COLORS() else{
> 					xx += spacing;
> 					text_ptr++;
> 				}
> 				continue;
> 			}
> 			
> //			ogl_ubitblt(FONT->ft_bitmaps[letter].bm_w,FONT->ft_bitmaps[letter].bm_h,xx,yy,0,0,&FONT->ft_bitmaps[letter],NULL);
> //			if (*text_ptr>='0' && *text_ptr<='9'){
> 			printf("%p\n",&FONT->ft_bitmaps[letter]);
> 			if (FFLAGS&FT_COLOR)
> 				gr_ubitmapm(xx,yy,&FONT->ft_bitmaps[letter]);
> 			else{
> 				if (grd_curcanv->cv_bitmap.bm_type==BM_OGL)
> 					ogl_ubitmapm_c(xx,yy,&FONT->ft_bitmaps[letter],FG_COLOR);
> 				else
> 					Error("ogl_internal_string: non-color string to non-ogl dest\n");
> //					gr_ubitmapm(xx,yy,&FONT->ft_bitmaps[letter]);//ignores color..
> 			}
> 			//}
> 
> 			xx += spacing;
> 
> 			text_ptr++;
> 		}
> 
> 	}
> 	return 0;
> }
> int gr_internal_color_string(int x, int y, char *s ){
> 	return ogl_internal_string(x,y,s);
> }
> 
> #endif // OGL
> 
1118a1406
> #ifdef __ENV_MSDOS__
1123a1412
> #endif
1248a1538,1539
> #define swapshort(a) (a)
> #define swapint(a) (a)
1251a1543
> 	old_grs_font *oldfont;
1284c1576,1578
< 	font = (grs_font *) malloc(datasize);
---
> 	oldfont = (old_grs_font *) malloc(datasize);
> 	font = (grs_font *) malloc(sizeof(grs_font));
> 	font->oldfont = oldfont;
1288c1582,1590
< 	cfread(font,1,datasize,fontfile);
---
> 	cfread(oldfont,1,datasize,fontfile);
>         font->ft_flags=swapshort(oldfont->ft_flags);
>         font->ft_w=swapshort(oldfont->ft_w);
>         font->ft_h=swapshort(oldfont->ft_h);
>         font->ft_baseline=swapshort(oldfont->ft_baseline);
>         font->ft_maxchar=oldfont->ft_maxchar;
>         font->ft_minchar=oldfont->ft_minchar;
>         font->ft_bytewidth=swapshort(oldfont->ft_bytewidth);
> 
1307c1609
< 		font->ft_widths = (short *) (((int) font->ft_widths) + ((ubyte *) font));
---
> 		font->ft_widths = (short *) (((int) oldfont->ft_widths) + ((ubyte *) oldfont));
1311c1613
< 			font->ft_widths[i] = SWAPSHORT(font->ft_widths[i]);
---
> 			font->ft_widths[i] = swapshort(oldfont->ft_widths[i]);
1314c1616
< 		font->ft_data = ((int) font->ft_data) + ((ubyte *) font);
---
> 		font->ft_data = ((int) oldfont->ft_data) + ((ubyte *) oldfont);
1330c1632
< 		font->ft_data = ((unsigned char *) font) + sizeof(*font);
---
> 		font->ft_data = ((unsigned char *) oldfont) + sizeof(*oldfont);
1339c1641
< 		font->ft_kerndata = ((int) font->ft_kerndata) + ((ubyte *) font);
---
> 		font->ft_kerndata = swapint(((int) oldfont->ft_kerndata) + ((ubyte *) oldfont));
1386a1689,1692
> 
> #ifdef OGL
> 	ogl_init_font(font);
> #endif
